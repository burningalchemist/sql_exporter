# -- Provide a name in place of `sql-exporter`
nameOverride: ""
# -- String to fully override "sql-exporter.fullname"
fullnameOverride: ""

image:
  # -- Image repository
  repository: burningalchemist/sql_exporter
  # -- Image pull policy
  pullPolicy: IfNotPresent
  # -- Image tag
  # @default -- `appVersion` value from `Chart.yaml`
  tag: ""

# -- Secrets with credentials to pull images from a private registry
imagePullSecrets: []
service:
  # -- Service type
  type: ClusterIP
  # -- Service port
  port: 80
  # -- Service labels
  labels: {}
  # -- Service annotations
  annotations:
    {}
    # example of prometheus usage
    # prometheus.io/scrape: "true"
    # prometheus.io/path: "/metrics"
extraContainers:
  - name: cloud-sql-proxy
    image: gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.8-alpine
    args:
      # Enables Automatic IAM Authentication for all instances
      - "--auto-iam-authn"
      # Enable structured logging with LogEntry format:
      - "--structured-logs"
      # Debug flag
      - "--debug"
      # If connecting from a VPC-native GKE cluster, use the
      # following flag to have the proxy connect over private IP
      - "--private-ip"
      # Enable the admin api server on port 9091
      - "--admin-port=9091"
      # Enable the /quitquitquit admin api endpoint for non-root SIGTERM
      - "--quitquitquit"
      # Tell the proxy to exit gracefully if it receives a SIGTERM
      - "--exit-zero-on-sigterm"
      # Replace DB_PORT with the port the proxy should listen on
      - "--port=5432"
      # Replace with the DB connection name
      - "xpanse-pre-aw-svc-asset-inv:us-central1:expander-api-db-fr-dev"
    securityContext:
      # The default Cloud SQL proxy image runs as the
      # "nonroot" user and group (uid: 65532) by default.
      runAsNonRoot: false
    # Resource configuration depends on an application's requirements. You
    # should adjust the following values based on what your application
    # needs. For details, see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    resources:
      requests:
        # The proxy's memory use scales linearly with the number of active
        # connections. Fewer open connections will use less memory. Adjust
        # this value based on your application's requirements.
        memory: "2Gi"
        # The proxy's CPU use scales linearly with the amount of IO between
        # the database and the application. Adjust this value based on your
        # application's requirements.
        cpu:    "1"


serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations:
    iam.gke.io/gcp-service-account: "tenant-service-db-user@xpanse-pre-aw-svc-asset-inv.iam.gserviceaccount.com"

  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: "db-proxy"

#  name: "my_kubernetes_sa"
# Example Annotations
#  annotations: {
#    iam.gke.io/gcp-service-account: my-service-account@gke.url
#  }

# -- Resource limits and requests for the application controller pods
resources: {}
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# -- Pod labels
podLabels: {}
# -- Pod annotations
podAnnotations: {}

# -- Pod security context
podSecurityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000
# @ignored
securityContext: {}

# Prometheus Operator values
serviceMonitor:
  # -- Enable ServiceMonitor
  enabled: true
  # -- ServiceMonitor interval
  interval: 15s
  # -- ServiceMonitor path
  path: /metrics
  # -- ServiceMonitor scrape timeout
  # scrapeTimeout: 10s
  # -- ServiceMonitor metric relabelings
  metricRelabelings: {}

# Additional env variables
# - kind should be either Secret or ConfigMap
# - name is the name of the Secret or ConfigMap that should be used
# - key is the key of the object inside of a Secret or ConfigMap
# env:
#   SQLEXPORTER_TARGET_DSN:
#     from:
#       kind: Secret
#       name: sql_exporter_secret
#       key: CONNECTION_STRING
# envFrom:
#   - configMapRef:
#       name: env-configmap
#   - secretRef:
#       name: env-secrets
# extraVolumes:
#   - name: configmap-mount
#     volume:
#       configMap:
#         name: log-config
#         items:
#           - key: log_level
#             path: log_level
#     mount:
#       readOnly: true
#       mountPath: /etc/config
# Set to true to create a config as a part of the helm chart
createConfig: true
config:
  global:
    # -- Scrape timeout
    scrape_timeout: 10s
    # -- Scrape timeout offset. Must be strictly positive.
    scrape_timeout_offset: 500ms
    # -- Minimum interval between collector runs.
    min_interval: 0s
    # -- Number of open connections.
    max_connections: 3
    # -- Number of idle connections.
    max_idle_connections: 3
# Target and collectors are not set so the chart is more flexible. Please configure it yourself.
# target:
#   data_source_name: 'sqlserver://prom_user:prom_password@dbserver1.example.com:1433'
#   collectors: [active_connections]
# collectors:
#   - collector_name: active_connections
#     metrics:
#       - metric_name: active_connections
#         type: gauge
#         help: 'Active connections'
#         key_labels:
#           - "datname"
#           - "usename"
#           - "state"
#         values:
#           - "count"
#         query_ref: active_connections
#     queries:
#       - query_name: active_connections
#         query: |
#                 SELECT
#                   datname::text,
#                   usename::text,
#                   state::text,
#                   COUNT(state)::float AS count
#                 FROM pg_stat_activity
#                 GROUP BY datname, usename, state;
# collector_files:
#    - "*.collector.yml"
# ---------------------------------------------------------------------
# -- Collector Files
# ---------------------------------------------------------------------
# -- Collector files are mounted to /etc/sql_exporter/collectors dir
# ---------------------------------------------------------------------
# collectorFiles:
#   pricing_data_freshness.collector.yml:
#     collector_name: pricing_data_freshness
#     metrics:
#       - metric_name: pricing_update_time
#         type: gauge
#         help: 'Time when prices for a market were last updated.'
#         key_labels:
#           # Populated from the `market` column of each row.
#           - Market
#         static_labels:
#           # Arbitrary key/value pair
#           portfolio: income
#         values: [LastUpdateTime]
#         query: |
#           SELECT Market, max(UpdateTime) AS LastUpdateTime
#           FROM MarketPrices
#           GROUP BY Market
