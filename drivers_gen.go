//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"sort"
)

const (
	packageName = "sql_exporter"
	filename    = "drivers.go"
)

var driverList = map[string][]string{
	"minimal": {
		"github.com/go-sql-driver/mysql",
		"github.com/lib/pq",
		"github.com/microsoft/go-mssqldb/azuread",
	},
	"extra": {
		"github.com/ClickHouse/clickhouse-go/v2",
		"github.com/jackc/pgx/v5/stdlib",
		"github.com/snowflakedb/gosnowflake",
		"github.com/vertica/vertica-sql-go",
		"github.com/sijms/go-ora/v2",
	},
	"custom": {
		"github.com/mithrandie/csvq-driver",
	},
}

func main() {
	// Accept either os.Args[2:] (keeps compatibility with previous usage)
	// or os.Args[1:] (simple "go run drivers_gen.go minimal")
	var args []string
	if len(os.Args) >= 3 {
		args = os.Args[2:]
	} else {
		args = os.Args[1:]
	}

	if len(args) == 0 {
		fmt.Printf("Usage: go run drivers_gen.go <key>\nAvailable keys:\n")
		// Print keys in deterministic order
		keys := make([]string, 0, len(driverList))
		for k := range driverList {
			keys = append(keys, k)
		}
		fmt.Printf(" - all\n")
		for _, k := range keys {
			fmt.Printf(" - %s\n", k)
		}
		os.Exit(1)
	}

	key := args[0]
	var enabledDrivers []string

	if key == "all" {
		for k, list := range driverList {
			if k == "custom" {
				continue
			}
			enabledDrivers = append(enabledDrivers, list...)
		}
	} else {
		list, ok := driverList[key]
		if !ok {
			fmt.Printf("Nonexistent key '%s'. Do nothing.\n", key)
			os.Exit(0)
		}
		enabledDrivers = append(enabledDrivers, list...)
	}

	if len(enabledDrivers) == 0 {
		fmt.Println("No drivers selected; nothing to do.")
		os.Exit(0)
	}

	// Create file contents
	var b bytes.Buffer
	fmt.Fprintf(&b, "// Code generated by \"drivers_gen.go\"\n\n")
	fmt.Fprintf(&b, "package %s\n\n", packageName)
	fmt.Fprintf(&b, "import (\n")
	// Keep order stable and de-duplicate just in case
	seen := map[string]bool{}
	for _, d := range enabledDrivers {
		seen[d] = true
	}
	unique := make([]string, 0, len(seen))
	for d := range seen {
		unique = append(unique, d)
	}
	sort.Strings(unique)
	for _, d := range unique {
		fmt.Fprintf(&b, "\t_ %q\n", d)
	}
	fmt.Fprintf(&b, ")\n")

	// Format using gofmt
	src, err := format.Source(b.Bytes())
	if err != nil {
		// If formatting fails, write the unformatted source and print a warning
		fmt.Println("warning: go/format failed:", err)
		src = b.Bytes()
	}

	// Print what will be written
	fmt.Println("Following drivers are to be added:")
	for _, v := range unique {
		fmt.Printf("> %s\n", v)
	}
	fmt.Printf("Save to '%s'\n", filename)

	if err := os.WriteFile(filename, src, 0644); err != nil {
		fmt.Println("error writing file:", err)
		os.Exit(1)
	}
}
